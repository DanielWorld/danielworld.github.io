<!DOCTYPE html>
<html lang="en">

<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>RecyclerView Prefetch</title>

    <!-- Bootstrap Core CSS -->
    <link href="vendor/bootstrap/css/bootstrap.min.css" rel="stylesheet">

    <!-- Theme CSS -->
    <link href="css/clean-blog.min.css" rel="stylesheet">

    <!-- Custom Fonts -->
    <link href="vendor/font-awesome/css/font-awesome.min.css" rel="stylesheet" type="text/css">
    <link href='https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/css'>

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <style>
.caption {
    font-size: 14px;
    padding: 10px;
    font-style: normal;
    margin: 0;
    display: block;
    border-bottom-right-radius: 5px;
    border-bottom-left-radius: 5px;
}

li {
    margin:5px 0px;
}

    </style>
</head>

<body>

    <!-- Navigation -->
    <nav class="navbar navbar-default navbar-custom navbar-fixed-top">
        <div class="container-fluid">
            <!-- Brand and toggle get grouped for better mobile display -->
            <div class="navbar-header page-scroll">
                <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
                    <span class="sr-only">Toggle navigation</span>
                    Menu <i class="fa fa-bars"></i>
                </button>
                <a class="navbar-brand" href="index.html">Daniel 의 개발 블로그</a>
            </div>

            <!-- Collect the nav links, forms, and other content for toggling -->
            <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="index.html">Home</a>
                    </li>
                    <li>
                        <a href="about.html">About</a>
                    </li>
                    <li>
                        <a href="post1.html">Sample Post</a>
                    </li>
                    <li>
                        <a href="contact.html">Contact</a>
                    </li>
                </ul>
            </div>
            <!-- /.navbar-collapse -->
        </div>
        <!-- /.container -->
    </nav>

    <!-- Page Header -->
    <!-- Set your background image for this header on the line below. -->
    <header class="intro-header" style="background-image: url('img/post-bg.jpg')">
        <div class="container">
            <div class="row">
                <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                    <div class="post-heading">
                        <h1>RecyclerView Prefetch</h1>
                        <h2 class="subheading">Smoother Flings and Scrolls by Doing Stuff Sooner</h2>
                        <span class="meta">Posted by <a href="#">Daniel Park</a> on April 1, 2017</span>
                    </div>
                </div>
            </div>
        </div>
    </header>

    <!-- Post Content -->
    <article>
        <div class="container">
            <div class="row">
                <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">

                    <blockquote>
                        <p>
                            <a target="_blank" href="https://medium.com/google-developers/recyclerview-prefetch-c2f269075710">RecyclerView Prefetch</a> 는 원본글 입니다.
                        </p>
                    </blockquote>

                    <h3>The Problem</h3>

                    <p>
                        During a scroll or fling operation, RecyclerView will need to display new items as they arrive on screen. These new items need to be bound to the data (and possibly created, if there are no items like it in the cache). Then they need to be laid out and drawn. When all of this is done lazily, just before it is needed, the UI thread can grind to a halt while the work completes. Then rendering can proceed and the scroll (or fling, but I’ll just refer to either as “scroll” from here on to simplify things) can get back to moving along smoothly… until the next new item comes into view.
                    </p>

                    <a href="#">
                        <img class="img-responsive" src="https://cdn-images-1.medium.com/max/750/1*X9E34oKRhAJbG-uSrhv-TA.png" alt="">
                    </a>
                    <span class="caption text-muted">
                        Typical rendering phases of RecyclerView content during a scroll (as of the Lollipop release). On the UI thread, we process input events, handle animations, perform layout, and record the drawing operations. Then the RenderThread (RT) sends the commands to the&nbsp;GPU.
                    </span>

                    <p>During most frames of a scroll, the RecyclerView has no problem doing what it needs to do, because there is no new content to deal with. During these frames, the UI thread processes input, handles animations, performs layout, and records drawing commands. It then syncs the drawing information over to the RenderThread (as of the <a href="https://developer.android.com/about/versions/lollipop.html" data-href="https://developer.android.com/about/versions/lollipop.html" target="_blank">Lollipop</a> release; prior releases do all of this work on the UI thread), which sends those commands over to the GPU.</p>

                    <a href="#">
                        <img class="img-responsive" src="https://cdn-images-1.medium.com/max/1200/1*DIr64fruHL5lp72Ji-b7rw.png" alt="">
                    </a>
                    <span class="caption text-muted">
                        New items cause the Input stage to take longer as new views are created, bound, and laid out. This results in a later start for the Render stage, which might cause it to finish after the frame boundary, resulting in a missed frame.                    
                    </span>
          
                    <p>When a new item comes on screen, more work is required in the input stage to bind, and possibly create, the appropriate views. This pushes the rest of the UI thread work later, as well as the ensuing work of the RenderThread, and can cause jank if it cannot all happen within the frame boundary.</p>

                    <a href="#">
                        <img class="img-responsive" src="https://cdn-images-1.medium.com/max/1200/1*R0vg4lvbNilR1xB5Qrawmw.png" alt="">
                    </a>
                    <span class="caption text-muted">
                        The call stack during input shows that new items coming into view cause a large chunk of time to be spent creating and binding the new views                    
                    </span>

                    <p>Examining the call stack during the input phase when these new items come in shows us that a large portion of the time is spent creating and binding the views.</p>

                    <p>Wouldn’t it be nice if we could do that work elsewhere instead of delaying everything while we get those new items ready?</p>

                    <a href="#">
                        <img class="img-responsive" src="https://cdn-images-1.medium.com/max/1200/1*2XWNdvsSwW8-L_DQwYxLxw.png" alt="">
                    </a>
                    <span class="caption text-muted">
                        Creating and binding views has to be done before they can be rendered, which takes up valuable time on the UI thread during the frame in which they’re needed. But meanwhile, that thread spends a lot of time idling in the previous frame…                    
                    </span>

                    <p>This is the observation that <a href="http://androidbackstage.blogspot.com/2015/07/this-time-tor-and-chet-are-joined-by.html" target="_blank">Chris Craik</a> (a graphics engineer on the Android UI Toolkit team) made when he was looking at <a href="https://developer.android.com/studio/profile/systrace.html" target="_blank">Systraces</a> of RecyclerView scrolls. Specifically, he saw that we’re spending a lot of time getting the items ready right when they’re needed. But meanwhile, just a frame before that, the UI thread was spending a lot of the time in that frame sleeping, because it finished its tasks early.</p>

                    <h3>The Solution</h3>

                    <a href="#">
                        <img class="img-responsive" src="https://cdn-images-1.medium.com/max/1200/1*_qCP_uaM8nMSlgqU6L1CxA.png" alt="">
                    </a>
                    <span class="caption text-muted">
                        Moving the creation and bind operations to the previous frame allows the UI Thread to do that work in parallel with the RenderThread, and avoids doing it later when it has to be done synchronously before the RenderThread can draw the results.                    
                    </span>

                    <p>Obviously, it was time to play around with time. Specifically, Chris rearranged the way things happen in the default RecyclerView layouts such that it now pre-fetches items that are about to come into view, so that we do this work during an idle phase, and avoid doing it later when everyone’s waiting for those results.</p>

                    <p>Now the work can happen essentially for free. Because the UI Thread was not doing any work in that gap between frames, we’re able to use that idle time to get work done that we will need later, and make that future frame that much faster because the hard part is already done.</p>

                    <h3>Details, Details</h3>

                    <p>The system works by scheduling a Runnable whenever RecyclerView starts a scrolling operation. This Runnable performs the prefetch of items that should come into view soon, depending on the layout manager and the direction that the views are being scrolled. Prefetching is not limited to a single item, either; it can fetch multiple items at once, such as when a row of GridLayoutManager items is coming on screen. In v25.1, prefetch operations are broken up into individual create/bind operations, which fit more easily into the UI thread gaps than operations on whole groups of items.</p>

                    <p>One of the interesting things about the prefetch approach is that the system has to predict how much time operations will take, and whether they can fit within the available gap. After all, if prefetch work delayed that frame past its deadline, we may still have jank from a skipped frame, just in a different place than we would without the prefetch. The way that the system handles this detail is by tracking the average create/bind durations per view type, enabling reasonable prediction of future create/bind operations.</p>

                    <p>Performing this work for nested RecyclerViews (containers whose items are, themselves, RecyclerViews) is trickier, since binding the inner RecyclerView doesn’t allocate any children — RecyclerView fetches children on demand when it’s attached and laid out. The prefetching system can still prepare children within that inner RecyclerView, but it has to know how many. This is the reason for the new API in v25.1 of LinearLayoutManager, 
                        <a href="https://developer.android.com/reference/android/support/v7/widget/LinearLayoutManager.html#setInitialPrefetchItemCount%28int%29" data-href="https://developer.android.com/reference/android/support/v7/widget/LinearLayoutManager.html#setInitialPrefetchItemCount(int)" target="_blank">setInitialItemPrefetchCount()</a>, which tells the system how many items to prefetch to fill the RecyclerView when it’s about to scroll on screen.
                    </p>

                    <h3>Caveats</h3>

                    <p>
                        There are a some important caveats here to be aware of:
                    </p>

                    <ul>
                        <li>Pre-fetching may do work that ends up not being needed. Because we are pre-fetching a view, it is possible that we are doing this too aggressively, and that the RecyclerView will not get to the item in question. This means that our pre-fetching work may be wasted (although since it happened in parallel, this should not be a big deal. Besides, this should be pretty uncommon because we are fetching very soon before it is needed, and it’s unlikely that the scroll will stop or reverse between those two frames).</li>
                        <li>RenderThread: The RenderThread was a performance feature introduced in Lollipop, to offload rendering onto a different thread and allow for some improvements such as running some immutable animations (for example, ripples and circular reveals) completely on the RenderThread, without being affected by UI Thread stalls. This means that devices running on releases earlier than Lollipop will not benefit from this optimization, because we cannot parallelize this work.</li>
                    </ul>

                    <h3>I Want Some - Where Can I Get It?</h3>

                    <p>The pre-fetch optimizations were introduced in 
                        <a href="https://developer.android.com/topic/libraries/support-library/revisions.html#rev25-0-0" data-href="https://developer.android.com/topic/libraries/support-library/revisions.html#rev25-0-0" target="_blank">Support Library v25</a>, with further enhancements in <a href="https://developer.android.com/topic/libraries/support-library/revisions.html#25-1-0" data-href="https://developer.android.com/topic/libraries/support-library/revisions.html#25-1-0" target="_blank">v25.1.0</a>. So the first step is to get the <a href="https://developer.android.com/topic/libraries/support-library/revisions.html" data-href="https://developer.android.com/topic/libraries/support-library/revisions.html" target="_blank">latest version</a> of the Support Library.</p>

                    <p>
                        If you use the default layout managers provided with RecyclerView, you will automatically get this optimization. However, if you are using nested RecyclerViews, or you wrote your own layout manager, you will need to change your code in order to take advantage of this feature.
                    </p>

                    <p>For nested RecyclerViews, call LinearLayoutManager’s new <a href="https://developer.android.com/reference/android/support/v7/widget/LinearLayoutManager.html#setInitialPrefetchItemCount%28int%29" data-href="https://developer.android.com/reference/android/support/v7/widget/LinearLayoutManager.html#setInitialPrefetchItemCount%28int%29" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">setInitialItemPrefetchCount()</a> method (available in v25.1) on the inner LayoutManagers to get the best performance. For example, if rows in your vertical list show over three items at a minimum, call setInitialItemPrefetchCount(4).</p>

                    <p>If you’ve implemented your own LayoutManager, you will need to override <a href="https://developer.android.com/reference/android/support/v7/widget/RecyclerView.LayoutManager.html#collectAdjacentPrefetchPositions%28int,%20int,%20android.support.v7.widget.RecyclerView.State,%20android.support.v7.widget.RecyclerView.LayoutManager.LayoutPrefetchRegistry%29" data-href="https://developer.android.com/reference/android/support/v7/widget/RecyclerView.LayoutManager.html#collectAdjacentPrefetchPositions(int, int, android.support.v7.widget.RecyclerView.State, android.support.v7.widget.RecyclerView.LayoutManager.LayoutPrefetchRegistry)" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">LayoutManager.collectAdjacentPrefetchPositions()</a>, which is called by RecyclerView when prefetch is enabled (the default implementation in LayoutManager does nothing). Secondly, if you want prefetching to occur from your LayoutManager when its RecyclerView is nested in another, you should also implement <a href="https://developer.android.com/reference/android/support/v7/widget/RecyclerView.LayoutManager.html#collectInitialPrefetchPositions%28int,%20android.support.v7.widget.RecyclerView.LayoutManager.LayoutPrefetchRegistry%29" data-href="https://developer.android.com/reference/android/support/v7/widget/RecyclerView.LayoutManager.html#collectInitialPrefetchPositions(int, android.support.v7.widget.RecyclerView.LayoutManager.LayoutPrefetchRegistry)" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">LayoutManager.collectInitialPrefetchPositions()</a>.</p>

                    <p>As always, it is worth optimizing both your create and bind steps, doing as little work as possible. <span class="markup--quote markup--p-quote is-other" name="anon_ab1d7665d4cb" data-creator-ids="anon">The fastest code is that which doesn’t have to run;</span> even when the framework can parallelize work done through prefetching, it still takes time, and expensive item creation can still cause jank. For example, a minimal view tree will always be cheaper to create and bind than a more complex one. And binding should essentially be as simple and fast as calling setters. Even if you are able to skate by under the frame time limit with your current code, optimizing it further means you will be more likely to run well on users’ lower-end devices, and saving performance even on higher-end devices always has battery benefits for these common situations. If you’ve already gotten the creation and bind as fast as they can be, then prefetching should help you hide the remaining time in the gap between frames.</p>
                    
                    <p>If you want to see the optimization in action, either in one of the default LayoutManagers or in a custom LayoutManager of yours, you can toggle <a href="https://developer.android.com/reference/android/support/v7/widget/RecyclerView.LayoutManager.html#setItemPrefetchEnabled%28boolean%29" data-href="https://developer.android.com/reference/android/support/v7/widget/RecyclerView.LayoutManager.html#setItemPrefetchEnabled(boolean)" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">LayoutManager.setItemPrefetchEnabled()</a> and compare the results. You should be able to see the results visually; it really is that significant, especially with items that take a significant amount of time to create and bind. But if you want to see what’s going on under the hood, run a <a href="https://developer.android.com/studio/profile/systrace.html" data-href="https://developer.android.com/studio/profile/systrace.html" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">Systrace</a>, or enable <a href="https://developer.android.com/studio/profile/dev-options-rendering.html" data-href="https://developer.android.com/studio/profile/dev-options-rendering.html" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">GPU profiling</a>, with and without prefetch enabled.</p>
                    
                    <a href="#">
                        <img class="img-responsive" src="https://cdn-images-1.medium.com/max/1600/1*gmuFD82uYJmGVVEPFxs6ag.png" alt="">
                    </a>
                    <span class="caption text-muted">
                        Systrace showing prefetch occurring during the otherwise idle time of the UI thread                    
                    </span>

                </div>
            </div>
        </div>
    </article>

    <hr>

    <!-- Footer -->
    <footer>
        <div class="container">
            <div class="row">
                <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                    <ul class="list-inline text-center">
                        <li>
                            <a href="#">
                                <span class="fa-stack fa-lg">
                                    <i class="fa fa-circle fa-stack-2x"></i>
                                    <i class="fa fa-twitter fa-stack-1x fa-inverse"></i>
                                </span>
                            </a>
                        </li>
                        <li>
                            <a href="#">
                                <span class="fa-stack fa-lg">
                                    <i class="fa fa-circle fa-stack-2x"></i>
                                    <i class="fa fa-facebook fa-stack-1x fa-inverse"></i>
                                </span>
                            </a>
                        </li>
                        <li>
                            <a href="#">
                                <span class="fa-stack fa-lg">
                                    <i class="fa fa-circle fa-stack-2x"></i>
                                    <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                                </span>
                            </a>
                        </li>
                    </ul>
                    <p class="copyright text-muted">Copyright &copy; <a target="_blank" href="https://github.com/danielworld">https://github.com/danielworld</a></p>
                </div>
            </div>
        </div>
    </footer>

    <!-- jQuery -->
    <script src="vendor/jquery/jquery.min.js"></script>

    <!-- Bootstrap Core JavaScript -->
    <script src="vendor/bootstrap/js/bootstrap.min.js"></script>

    <!-- Contact Form JavaScript -->
    <script src="js/jqBootstrapValidation.js"></script>
    <script src="js/contact_me.js"></script>

    <!-- Theme JavaScript -->
    <script src="js/clean-blog.min.js"></script>

</body>

</html>
